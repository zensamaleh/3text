import { useState, useCallback } from 'react'\nimport { RAGService } from '../lib/ragService'\nimport { EmbeddingService } from '../lib/embeddingService'\nimport { DatasetService } from '../lib/datasetService'\nimport type { \n  RAGConfig, \n  RAGSearchResult, \n  IndexingStats\n} from '../types/rag.types'\nimport { DEFAULT_RAG_CONFIG, EMBEDDING_PROVIDERS } from '../types/rag.types'\n\ninterface UseRAGOptions {\n  gemId?: string\n  autoDetectProvider?: boolean\n}\n\nexport function useRAG(options: UseRAGOptions = {}) {\n  const [ragService] = useState(() => RAGService.getInstance())\n  const [embeddingService] = useState(() => EmbeddingService.getInstance())\n  \n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n  const [lastSearchResult, setLastSearchResult] = useState<RAGSearchResult | null>(null)\n\n  const detectBestProvider = useCallback((): keyof typeof EMBEDDING_PROVIDERS => {\n    if (embeddingService.getGeminiApiKey()) {\n      return 'gemini-embedding-004'\n    }\n    if (embeddingService.getOpenAIApiKey()) {\n      return 'openai-3-small'\n    }\n    throw new Error('Aucun provider d\\'embeddings configuré')\n  }, [])\n\n  const checkAvailability = useCallback(async (gemId?: string) => {\n    const targetGemId = gemId || options.gemId\n    if (!targetGemId) {\n      throw new Error('Gem ID requis')\n    }\n\n    try {\n      const hasEmbeddings = await ragService.hasEmbeddings(targetGemId)\n      const providerConfigured = embeddingService.isConfigured()\n      \n      return {\n        available: hasEmbeddings && providerConfigured,\n        hasEmbeddings,\n        providerConfigured,\n        gemId: targetGemId\n      }\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Erreur vérification RAG')\n      return {\n        available: false,\n        hasEmbeddings: false,\n        providerConfigured: false,\n        gemId: targetGemId\n      }\n    }\n  }, [options.gemId, ragService, embeddingService])\n\n  const search = useCallback(async (\n    query: string, \n    gemId?: string,\n    customConfig?: Partial<RAGConfig>\n  ): Promise<RAGSearchResult | null> => {\n    const targetGemId = gemId || options.gemId\n    if (!targetGemId) {\n      throw new Error('Gem ID requis')\n    }\n\n    setLoading(true)\n    setError(null)\n\n    try {\n      let config = { ...DEFAULT_RAG_CONFIG, ...customConfig }\n      \n      if (options.autoDetectProvider) {\n        config.embeddingProvider = detectBestProvider()\n      }\n\n      const result = await ragService.searchSimilar(targetGemId, query, config)\n      setLastSearchResult(result)\n      return result\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Erreur de recherche RAG'\n      setError(errorMessage)\n      return null\n    } finally {\n      setLoading(false)\n    }\n  }, [options.gemId, options.autoDetectProvider, ragService, detectBestProvider])\n\n  const searchForAI = useCallback(async (\n    query: string,\n    gemId?: string,\n    customConfig?: Partial<RAGConfig>\n  ) => {\n    const targetGemId = gemId || options.gemId\n    if (!targetGemId) {\n      throw new Error('Gem ID requis')\n    }\n\n    setLoading(true)\n    setError(null)\n\n    try {\n      let config = { ...DEFAULT_RAG_CONFIG, ...customConfig }\n      \n      if (options.autoDetectProvider) {\n        config.embeddingProvider = detectBestProvider()\n      }\n\n      const result = await ragService.searchForAI(targetGemId, query, config)\n      setLastSearchResult(result.searchResult)\n      return result\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Erreur de recherche RAG pour IA'\n      setError(errorMessage)\n      return null\n    } finally {\n      setLoading(false)\n    }\n  }, [options.gemId, options.autoDetectProvider, ragService, detectBestProvider])\n\n  const clearError = useCallback(() => setError(null), [])\n\n  return {\n    search,\n    searchForAI,\n    checkAvailability,\n    detectBestProvider,\n    loading,\n    error,\n    lastSearchResult,\n    clearError,\n    ragService,\n    embeddingService\n  }\n}